#!/usr/bin/env python
from __future__ import print_function

import collections
import json
import os
import re
import subprocess
import sys
import datetime

import jsonrpclib
import yaml

from subprocess import Popen, PIPE, STDOUT, CalledProcessError
from six import iteritems

import Logging
import Tac
__version__ = "0.2.0"

# BEGIN - SETTINGS
USER = "{{ settings.ftp_user }}"
IMAGES_URL = "{{ settings.images_url }}"
REPORTS_URL = "{{ settings.reports_url }}"
IMAGES = collections.OrderedDict([
{%- for image in images %}
    (r"{{ image.pattern }}", ("{{ image.image }}", "{{ image.version }}")),
{%- endfor %}
])

Tac.singleton( "Tac::LogManager" ).syslogFacility = 'logLocal4'
Logging.logD(id="SYS_EVENT_REIMAGE_INFO",
             severity=Logging.logInfo,
             format="%s",
             explanation="[ Informational log message ]",
             recommendedAction=Logging.NO_ACTION_REQUIRED)

Logging.logD(id="SYS_EVENT_REIMAGE_EAPIERR",
             severity=Logging.logError,
             format="%s",
             explanation="[ eAPI command returned an error ]",
             recommendedAction=Logging.NO_ACTION_REQUIRED)

Logging.logD(id="SYS_EVENT_REIMAGE_CALLERR",
             severity=Logging.logError,
             format="%s",
             explanation="[ an attempt to run shell command has failed ]",
             recommendedAction=Logging.NO_ACTION_REQUIRED)

Logging.logD(id="SYS_EVENT_REIMAGE_LEDERR",
             severity=Logging.logWarning,
             format="failed to enable locator LED",
             explanation="[ The led light has failed to turn on ]",
             recommendedAction=Logging.NO_ACTION_REQUIRED)

Logging.logD(id="SYS_EVENT_REIMAGE_FAILURE",
             severity=Logging.logError,
             format="%s",
             explanation="[ An unexpected error ]",
             recommendedAction=Logging.NO_ACTION_REQUIRED)
# END - SETTINGS

os.environ.update({"TERM": "dumb"})

def call(cmd, data=None):
    # Cll runs a shell command and capture output
    # return a tuple containing (stdout, stderr)
    stdout = None
    stderr = None
    err = None

    try:
        proc = Popen(cmd.split(), stdin=PIPE, stdout=PIPE, stderr=PIPE)
        stdout, stderr = proc.communicate(data)
        proc.wait()
        code = proc.returncode
        if code > 0:
            err = "'%s' returned error code %d" % (cmd, code)
    except CalledProcessError as e:
        err = e.message
    except IOError as e:
        err = e.strerror

    return stdout, stderr, err


def status_led_reset():
    return status_led_set("green", 0)

def status_led_set(color, flash=False):
    """
    LED Commands

    # 75xx
    locator-led module 1 # flashing red
    led set --device Status (-y|-r) # red
    led set --device Status -g # green
    led set --device Status (-r|-y) -f 1 # red flashing
    led set --device Status -g -f 1 # green flashing
    led set --device Status # off
    led set --device Beacon -g # blue
    led set --device Beacon # off
    led test Basic # resets to default

    # 7050
    locator-led chassis # solid blue
    led set --device Status -g # green
    led set --device Status (-y|-r) # red
    led set --device Status -b # blue
    led set --device Status -y -f 1 # red solid, does not flash
    led set --device Status -g -f 1 # green flash, dim
    led set --device Status -b -f 1 # blue solid, does not flash
    led set --device Status # off
    led test Basic # resets to default

    # 7280
    locator-led chassis # flashing blue
    led set --device Status -g # green
    led set --device Status (-y|-r) # red
    led set --device Status -b # blue, displays a warning
    led set --device Status -y -f 1 # red flashing
    led set --device Status -g -f 1 # green flashing
    led set --device Status -b -f 1 # blue flashing, displays a warning
    led set --device Status # off
    led test Basic # resets to default
    """
    if color not in ["green", "red", "blue"]:
        return "Only colors green and red are supported"

    flash = 1 if flash else 0
    
    if color == "blue":
        # try and use the beacon for chassis
        _, _, err = call("/usr/bin/env led set --device Beacon --%s --flash %d")
        if not err:
            _, _, err = call("/usr/bin/env led set --device Status")
            return err
    else:
        # attempt to turn off beacon
        _, _, err = call("/usr/bin/env led set --device Beacon")
    
    _, _, err = call("/usr/bin/env led set --device Status --%s --flash %d")

    return err

def configure(cmds):
    return eapi(["configure"] + cmds + ["end"])

def cleanup():
    pass

def eapi(cmds, format="json"):
    result = {}
    err = None

    sess = jsonrpclib.Server("unix:///var/run/command-api.sock")

    try:
        result = sess.runCmds(1, cmds, format)
    except jsonrpclib.jsonrpc.ProtocolError as e:
        err = "Error [%d]: %s" % e.message

    return result, err

def find_image(model):

    for (pattern, details) in iteritems(IMAGES):
        if re.search(pattern, model):
            return details, None

    return None, "No EOS version matched for this SKU"

def get_startup_config():
    result, err = eapi(["show startup-config"], "text")
    if result:
        result = result[0].get("output")

    return result, err

def get_sysinfo():
    result, err = eapi(["show version", "show boot-config"])

    if err:
        return result, err
    
    ver = result[0]
    boot = result[1]
    
    # vEOS has no serial use mac address...
    serial = ver["serialNumber"] or re.sub(r"[\:\.]+", "", ver["systemMacAddress"])
    startup = get_startup_config()
    result = {
        "model": ver["modelName"],
        "image": boot["softwareImage"],
        "version": ver["version"],
        "serial": serial,
        "internal": ver["internalVersion"],
        "revison": ver["hardwareRevision"],
        "start_empty": False if len(startup) > 0 else True
    }
    #logger.debug("Sysinfo: " + str(result))
    return result, err

# def reset():
#     call("rm /mnt/flash/zerotouch-config")
#     call("cat /dev/null > /mnt/flash/startup-config")

def send_report(serial, sysinfo, status="ok", message=""):

    data = {
        "timestamp": datetime.datetime.utcnow(),
        "status": status, 
        "message": message,
        "sysinfo": sysinfo
    }

    data = yaml.safe_dump(data, default_flow_style=False)

    url = REPORTS_URL + serial
    
    output, stderr, err = call("curl -s -T - -u %s %s"
                               % (USER, url), data)

    if err:
        err = "Failed to upload report: %s" % err
    
    return output, err

def main():
    Logging.log(SYS_EVENT_REIMAGE_INFO, "Getting system info")
    sysinfo, err = get_sysinfo()

    if err:
        # send_report(serial, sysinfo, status="failed",
        #             message=err)
        Logging.log(SYS_EVENT_REIMAGE_EAPIERR, err)
        return 1

    model = sysinfo["model"]
    running = sysinfo["version"]
    serial = sysinfo["serial"]

    # set hostname for logging
    configure(["hostname %s" % serial])

    Logging.log(SYS_EVENT_REIMAGE_INFO, "Sysinfo: SN:%s, Model:%s, Image:%s" %
                (serial, model, running))
    result, err = find_image(model)

    if err:
        Logging.log(SYS_EVENT_REIMAGE_FAILURE, err)
        return 1

    image, version = result

    if running != version:
        status_led_set("red", 1)
        
        Logging.log(SYS_EVENT_REIMAGE_INFO, "loading image '%s'" % image)
        dest = "/mnt/flash/%s" % image
        
        url = IMAGES_URL + image
        
        _, _, err = call("/usr/bin/curl -s -u %s -o %s %s"
            % (USER, dest, url))
        
        if err:
            Logging.log(SYS_EVENT_REIMAGE_CALLERR, "failed to copy image: %s" % err)
            return 1

        _, err = configure(["boot system flash:%s" % image])
        if err:
            Logging.log(SYS_EVENT_REIMAGE_EAPIERR, err)
            return 1
        
        Logging.log(SYS_EVENT_REIMAGE_INFO,
                        "system will now reboot to image '%s'" % image)
        
        _, _, err = call("sudo shutdown -r +1")
        if err:
            Logging.log(SYS_EVENT_REIMAGE_FAILURE, err)
            return 1
        Logging.log(SYS_EVENT_REIMAGE_INFO, "system reloading in 1 minute")
    else:
        status_led_set("green", 1)
        Logging.log(SYS_EVENT_REIMAGE_INFO, "New image running, erasing configuration...")
        _, err = eapi(["write erase now"])
        if err:
            Logging.log(SYS_EVENT_REIMAGE_FAILURE, err)
            return 1

        Logging.log(SYS_EVENT_REIMAGE_INFO, "startup-config erased")

        eapi(["delete flash:zerotouch-config"])

        Logging.log(SYS_EVENT_REIMAGE_INFO, "zerotouch provisioning re-enabled")
        
        # refresh sysinfo after erasing startup-config
        sysinfo, err = get_sysinfo()
        if err:
            Logging.log(SYS_EVENT_REIMAGE_FAILURE, err)
            return 1
        
        if os.path.exists("/mnt/flash/zerotouch-config"):
            Logging.log(SYS_EVENT_REIMAGE_FAILURE, "Failed to delete zerotouch-config")
            return 1

        _, err = send_report(serial, sysinfo)

        if err:
            Logging.log(SYS_EVENT_REIMAGE_FAILURE, err)
            return 1

        # turn on locator LED
        err = status_led_set("blue")
        if err:
            Logging.log(SYS_EVENT_REIMAGE_LEDERR)
        else:
            Logging.log(SYS_EVENT_REIMAGE_INFO, "locator LED enabled")
            
        Logging.log(SYS_EVENT_REIMAGE_INFO, "reimage complete")
    return 0

if __name__ == "__main__":
    sys.exit(main())
